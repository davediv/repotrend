---
import { formatDateDisplay, formatWeekRange, getSundayOfWeek, todayUTC } from "../lib/dates";

interface Props {
	selectedDate?: string;
	viewMode?: "daily" | "weekly";
}

const { selectedDate, viewMode = "daily" } = Astro.props;

const currentDate = selectedDate || todayUTC();
const displayText =
	viewMode === "weekly" ? formatWeekRange(currentDate) : formatDateDisplay(currentDate);
const datetimeAttr =
	viewMode === "weekly" ? `${currentDate}/${getSundayOfWeek(currentDate)}` : currentDate;
---

<div
	class="date-picker"
	role="group"
	aria-label="Date navigation"
	data-selected-date={currentDate}
	data-view-mode={viewMode}
>
	<button
		class="date-nav-btn"
		data-action="prev"
		type="button"
		aria-label={viewMode === "weekly" ? "Previous week" : "Previous day"}
		disabled
	>
		<svg
			xmlns="http://www.w3.org/2000/svg"
			width="18"
			height="18"
			viewBox="0 0 24 24"
			fill="none"
			stroke="currentColor"
			stroke-width="2"
			stroke-linecap="round"
			stroke-linejoin="round"
		>
			<polyline points="15 18 9 12 15 6"></polyline>
		</svg>
	</button>

	<div class="date-display-container">
		<button
			class="date-display"
			type="button"
			aria-label={`Selected date: ${displayText}. Click to open calendar.`}
		>
			<svg
				class="calendar-icon"
				xmlns="http://www.w3.org/2000/svg"
				width="16"
				height="16"
				viewBox="0 0 24 24"
				fill="none"
				stroke="currentColor"
				stroke-width="2"
				stroke-linecap="round"
				stroke-linejoin="round"
			>
				<rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
				<line x1="16" y1="2" x2="16" y2="6"></line>
				<line x1="8" y1="2" x2="8" y2="6"></line>
				<line x1="3" y1="10" x2="21" y2="10"></line>
			</svg>
			<time class="date-text" datetime={datetimeAttr}>{displayText}</time>
		</button>
		<input
			type="date"
			class="date-input-hidden"
			value={currentDate}
			step={viewMode === "weekly" ? "7" : undefined}
			tabindex={-1}
			aria-hidden="true"
		/>
	</div>

	<button
		class="date-nav-btn"
		data-action="next"
		type="button"
		aria-label={viewMode === "weekly" ? "Next week" : "Next day"}
		disabled
	>
		<svg
			xmlns="http://www.w3.org/2000/svg"
			width="18"
			height="18"
			viewBox="0 0 24 24"
			fill="none"
			stroke="currentColor"
			stroke-width="2"
			stroke-linecap="round"
			stroke-linejoin="round"
		>
			<polyline points="9 18 15 12 9 6"></polyline>
		</svg>
	</button>
</div>

<script>
	import { getMondayOfWeek, toDateString } from "../lib/dates";

	class DatePickerController {
		private prevBtn: HTMLButtonElement;
		private nextBtn: HTMLButtonElement;
		private displayBtn: HTMLButtonElement;
		private dateInput: HTMLInputElement;
		private selectedDate: string;
		private viewMode: "daily" | "weekly";
		private availableDates: string[] = [];

		constructor(container: HTMLElement) {
			this.selectedDate = container.dataset.selectedDate!;
			this.viewMode = (container.dataset.viewMode as "daily" | "weekly") || "daily";

			this.prevBtn = container.querySelector('[data-action="prev"]')!;
			this.nextBtn = container.querySelector('[data-action="next"]')!;
			this.displayBtn = container.querySelector(".date-display")!;
			this.dateInput = container.querySelector(".date-input-hidden")!;

			this.bindEvents();
			this.fetchDateRange();
		}

		private bindEvents(): void {
			this.prevBtn.addEventListener("click", () => this.navigate(-1));
			this.nextBtn.addEventListener("click", () => this.navigate(1));

			this.displayBtn.addEventListener("click", () => {
				try {
					this.dateInput.showPicker();
				} catch {
					this.dateInput.click();
				}
			});

			this.dateInput.addEventListener("change", () => {
				if (this.dateInput.value) {
					this.goToDate(this.dateInput.value);
				}
			});

			this.displayBtn.addEventListener("keydown", (e: KeyboardEvent) => {
				if (e.key === "ArrowLeft") {
					e.preventDefault();
					this.navigate(-1);
				} else if (e.key === "ArrowRight") {
					e.preventDefault();
					this.navigate(1);
				}
			});
		}

		private async fetchDateRange(): Promise<void> {
			try {
				const response = await fetch("/api/dates");
				if (!response.ok) return;

				const data: { earliest: string | null; latest: string | null; dates: string[] } =
					await response.json();

				this.availableDates = data.dates;

				if (data.earliest) {
					this.dateInput.min = data.earliest;
				}
				if (data.latest) {
					this.dateInput.max = data.latest;
				}

				this.updateButtonStates();
			} catch {
				// On failure, enable buttons as a fallback so navigation isn't stuck
				this.prevBtn.disabled = false;
				this.nextBtn.disabled = false;
			}
		}

		private navigate(direction: number): void {
			if (this.availableDates.length === 0) return;

			if (this.viewMode === "weekly") {
				this.navigateWeek(direction);
				return;
			}

			const currentIndex = this.availableDates.indexOf(this.selectedDate);

			let targetIndex: number;
			if (currentIndex === -1) {
				// Selected date is outside the available dates (e.g., today has no data).
				// Find the closest available date in the given direction.
				if (direction < 0) {
					targetIndex = this.findClosestBefore(this.selectedDate);
				} else {
					targetIndex = this.findClosestAfter(this.selectedDate);
				}
			} else {
				targetIndex = currentIndex + direction;
			}

			if (targetIndex < 0 || targetIndex >= this.availableDates.length) return;
			this.goToDate(this.availableDates[targetIndex]);
		}

		private navigateWeek(direction: number): void {
			const [y, m, d] = this.selectedDate.split("-").map(Number);
			const current = new Date(y, m - 1, d);
			current.setDate(current.getDate() + direction * 7);
			const target = getMondayOfWeek(toDateString(current));

			const earliest = this.availableDates[0];
			const latest = this.availableDates[this.availableDates.length - 1];

			// Don't navigate beyond the archive range
			const [ty, tm, td] = target.split("-").map(Number);
			const targetSunday = toDateString(new Date(ty, tm - 1, td + 6));

			if (direction < 0 && targetSunday < earliest) return;
			if (direction > 0 && target > latest) return;

			this.goToDate(target);
		}

		private findClosestBefore(date: string): number {
			for (let i = this.availableDates.length - 1; i >= 0; i--) {
				if (this.availableDates[i] < date) return i;
			}
			return -1;
		}

		private findClosestAfter(date: string): number {
			for (let i = 0; i < this.availableDates.length; i++) {
				if (this.availableDates[i] > date) return i;
			}
			return this.availableDates.length;
		}

		private goToDate(date: string): void {
			if (this.viewMode === "weekly") {
				window.location.href = `/trending/week/${getMondayOfWeek(date)}`;
			} else {
				window.location.href = `/trending/${date}`;
			}
		}

		private updateButtonStates(): void {
			if (this.availableDates.length === 0) return;

			const earliest = this.availableDates[0];
			const latest = this.availableDates[this.availableDates.length - 1];

			if (this.viewMode === "weekly") {
				const [y, m, d] = this.selectedDate.split("-").map(Number);
				const current = new Date(y, m - 1, d);

				const prevMonday = new Date(current);
				prevMonday.setDate(prevMonday.getDate() - 7);
				const prevSunday = new Date(prevMonday);
				prevSunday.setDate(prevSunday.getDate() + 6);
				this.prevBtn.disabled = toDateString(prevSunday) < earliest;

				const nextMonday = new Date(current);
				nextMonday.setDate(nextMonday.getDate() + 7);
				this.nextBtn.disabled = toDateString(nextMonday) > latest;
			} else {
				const currentIndex = this.availableDates.indexOf(this.selectedDate);

				// Disable prev if at or before the earliest available date
				this.prevBtn.disabled =
					currentIndex === 0 || (currentIndex === -1 && this.selectedDate <= earliest);

				// Disable next if at or after the latest available date
				this.nextBtn.disabled =
					currentIndex === this.availableDates.length - 1 ||
					(currentIndex === -1 && this.selectedDate >= latest);
			}
		}
	}

	document.querySelectorAll<HTMLElement>(".date-picker").forEach((el) => {
		new DatePickerController(el);
	});
</script>

<style>
	.date-picker {
		display: inline-flex;
		align-items: center;
		gap: 0.5rem;
	}

	.date-nav-btn {
		display: flex;
		align-items: center;
		justify-content: center;
		width: 36px;
		height: 36px;
		border: 1px solid var(--color-border);
		border-radius: 6px;
		background: var(--color-bg);
		color: var(--color-text-secondary);
		cursor: pointer;
		transition:
			color 0.15s,
			border-color 0.15s,
			background-color 0.15s;
	}

	.date-nav-btn:hover:not(:disabled) {
		color: var(--color-text);
		border-color: var(--color-border-hover);
		background-color: var(--color-bg-secondary);
	}

	.date-nav-btn:focus-visible {
		outline: 2px solid var(--color-accent);
		outline-offset: 2px;
	}

	.date-nav-btn:disabled {
		opacity: 0.4;
		cursor: not-allowed;
	}

	.date-display-container {
		position: relative;
	}

	.date-display {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		height: 36px;
		padding: 0 0.75rem;
		border: 1px solid var(--color-border);
		border-radius: 6px;
		background: var(--color-bg);
		color: var(--color-text);
		font-family: inherit;
		font-size: 0.875rem;
		font-weight: 500;
		cursor: pointer;
		white-space: nowrap;
		transition:
			border-color 0.15s,
			background-color 0.15s;
	}

	.date-display:hover {
		border-color: var(--color-border-hover);
		background-color: var(--color-bg-secondary);
	}

	.date-display:focus-visible {
		outline: 2px solid var(--color-accent);
		outline-offset: 2px;
	}

	.calendar-icon {
		color: var(--color-text-secondary);
		flex-shrink: 0;
	}

	.date-text {
		font-variant-numeric: tabular-nums;
	}

	.date-input-hidden {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		opacity: 0;
		pointer-events: none;
	}

	@media (max-width: 640px) {
		.date-picker {
			display: flex;
			width: 100%;
		}

		.date-nav-btn {
			width: 44px;
			height: 44px;
		}

		.date-display-container {
			flex: 1;
		}

		.date-display {
			width: 100%;
			height: 44px;
			font-size: 0.875rem;
			justify-content: center;
		}
	}
</style>
